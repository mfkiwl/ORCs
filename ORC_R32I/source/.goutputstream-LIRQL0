///////////////////////////////////////////////////////////////////////////////
// File name    : FIR_Filter.v
// Author       : Jose R Garcia
// Create Date  : 18/05/2020 19:25:32
// Project Name : Reusable Unit Library
// Unit Name    : FIR_Filter
// Description  : Scalable FIR filter with adjustable fixed point generic
//
// Additional Comments:
//    Coefficients have to be generate in Octave/Matlab.
///////////////////////////////////////////////////////////////////////////////

module FIR_Filter #(parameter P_COEFFICIENTS_MSB  = 23,   // xxxx.XXXX digits after the point
                              P_NUM_COEFFICIENTS  = 16,   // Number of filter coefficients
                              P_DATA_MSB          = 23,   // Must be smaller than g_IntegerDigits
                              P_WRITE_ADDRESS_MSB = 3     // log2(P_NUM_COEFFICIENTS)-1
                              )
  (
   // Input Signals
   input i_clk,   // Main Clock
   input i_reset, // Synchronous Reset
   // Streaming Data Signals
   output                o_ready_in,
   input                 i_valid_in,
   input  [P_DATA_MSB:0] i_data_in,  // Input Data
   input                 i_ready_out,
   output                o_valid_out,
   output [P_DATA_MSB:0] o_data_out, // Ouput Data
   // Asynch Memory Write Interface
   input                          i_wselect,    //
   input                          i_write,      //
   output                         o_wack,       //
   input  [P_COEFFICIENTS_MSB:0]  i_write_data, //
   input  [P_WRITE_ADDRESS_MSB:0] i_write_addr  //
  );

  /////////////////////////////////////////////////////////////////////////////
  // Internal Signal Declarations
  /////////////////////////////////////////////////////////////////////////////
  // Streaming In
  reg r_ready_in;
  // Streaming Out
  reg r_valid_out;
  // Accumulator Process
  reg signed [P_COEFFICIENTS_MSB:0] r_accumulator[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [P_DATA_MSB:0]         r_data_buffer[0:P_NUM_COEFFICIENTS-1]; // Adder and Multiplication accumulator.
  reg signed [P_DATA_MSB:0]         r_coefficients[0:P_NUM_COEFFICIENTS-1];// Adder and Multiplication accumulator.
  // Memory Write interface Signals
  reg r_wack; //
  // Counters
  integer ii = 0;
  integer kk = 0;
  integer jj = 0;

  ////////////////////////////////////////////////////////////////////////////
  // Internal Parameter Declarations
  ////////////////////////////////////////////////////////////////////////////
  localparam LP_GAIN_NORMALIZATION = 2**(((P_DATA_MSB+1)/2)-1);
  localparam LP_SHIFT_DEC_POINT    = $clog2(LP_GAIN_NORMALIZATION);

  /////////////////////////////////////////////////////////////////////////////
  //            ********      Architecture Declaration      ********
  /////////////////////////////////////////////////////////////////////////////

  // Ready assignment
  assign o_ready_in = r_ready_in | i_valid_in;

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Accumulator Process
  // Description : Accumulates the filtered samples.
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      r_valid_out = 1'b0;
      for(ii = 0; ii < P_NUM_COEFFICIENTS; ii = ii+1) begin
        r_accumulator[ii] <= 'b0;
        r_data_buffer[ii] <= 'b0;
      end
    end
    else if (i_wselect == 1'b0 && r_ready_in && 1'b1 && i_valid_in == 1'b1) begin
		  // Do the convolution. This is a Multiply then add then shift operation.
      r_data_buffer[0] <= i_data_in;
      r_accumulator[0] <= (i_data_in*r_coefficients[0]) >> LP_SHIFT_DEC_POINT;

      for(kk = 1; kk < P_NUM_COEFFICIENTS; kk = kk+1) begin
        // Loop over all the coefficients of the filter.
        r_accumulator[kk] <= (r_accumulator[kk-1]+(r_data_buffer[kk]*r_coefficients[kk])) >> LP_SHIFT_DEC_POINT;
        r_data_buffer[kk] <= r_data_buffer[kk-1];
      end

      // Create r_valid_data_in
      r_valid_out = 1'b1;
    end
    else if (i_wselect == 1'b1 || i_valid_in == 1'b0) begin
      // Create r_valid_data_in
      r_valid_out = 1'b0;
    end
  end

  // Assign register values to output signals
  assign r_ready_in  = !i_wselect & i_ready_out;
  assign o_valid_out = r_valid_out;
  assign o_data_out  = r_accumulator[P_NUM_COEFFICIENTS-1][P_DATA_MSB:0];

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Data Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      for(jj = 0; jj < P_NUM_COEFFICIENTS; jj = jj+1)
        r_coefficients[jj] <= 'h0;
    end
    else if (i_wselect == 1'b1 && i_write == 1'b1 && r_wack == 1'b0) begin
        r_coefficients[i_write_addr] <= i_write_data;
    end
  end

  /////////////////////////////////////////////////////////////////////////////
  // Process     : Asynch Memory Write Acknowledge Process
  // Description : Creates a write interface
  /////////////////////////////////////////////////////////////////////////////
  always @(negedge i_clk) begin
    if (i_reset == 1'b1) begin
      // Reset Signals
      r_wack <= 1'b0;
    end
    else if (i_wselect == 1'b1) begin
      if (i_write == 1'b0) begin
        r_wack <= 1'b0;
      end
      else begin
        r_wack <= 1'b1;
      end
    end
  end

  assign o_wack = r_wack;

endmodule // FIR_Filter
